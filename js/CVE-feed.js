fetch("https://corsproxy.io/?https://vulnerability.circl.lu/api/last")
	.then(res => res.json())
	.then(data => {
		const container = document.getElementById("cveList");
		if (!Array.isArray(data)) {
			container.innerHTML = "No threat data available.";
			return;
		}

		// Only use entries that have both an ID and a description
		const validEntries = data.filter(cve =>
			cve?.cveMetadata?.cveId &&
			cve?.containers?.cna?.descriptions?.[0]?.value
		);

		const truncate = (str, max = 80) =>
			str.length > max ? str.slice(0, max) + " ..." : str;

		const limited = validEntries.slice(0, 5);

		if (limited.length === 0) {
			container.innerHTML = "No valid CVE threats found.";
			return;
		}

		container.innerHTML = limited.map(cve => {
			const id = cve.cveMetadata.cveId;
			const desc = truncate(cve.containers.cna.descriptions[0].value);
			return `
      <div style="margin-bottom: 15px;">
        <strong style="color: #10cf44;">${id}</strong><br>
        <span>${desc}</span>
      </div>
    `;
		}).join('');
	})
	.catch(err => {
		console.error(err);
		document.getElementById("cveList").innerText = "Error loading threat data.";
	});



document.addEventListener('DOMContentLoaded', function () {
	const tabs = document.querySelectorAll('.explorer-tab');
	const contents = document.querySelectorAll('.explorer-content');

	tabs.forEach((tab, index) => {
		tab.addEventListener('click', () => {
			// Remove active class from all tabs and contents
			tabs.forEach(t => t.classList.remove('active'));
			contents.forEach(c => {
				c.classList.remove('active');
				c.classList.add('hidden');
			});

			// Add active class to clicked tab and show corresponding content
			tab.classList.add('active');
			if (contents[index]) {
				contents[index].classList.add('active');
				contents[index].classList.remove('hidden');
			}
		});
	});

	// Rest of your existing JavaScript...
});
// Tab functionality for Threat Explorer
document.addEventListener('DOMContentLoaded', function () {
	const tabs = document.querySelectorAll('.explorer-tab');
	const contents = document.querySelectorAll('.explorer-content');

	tabs.forEach((tab, index) => {
		tab.addEventListener('click', () => {
			// Remove active class from all tabs and contents
			tabs.forEach(t => t.classList.remove('active'));
			contents.forEach(c => c.classList.remove('active'));

			// Add active class to clicked tab and corresponding content
			tab.classList.add('active');
			if (contents[index]) {
				contents[index].classList.add('active');
			}
		});
	});

	// Industry selector functionality
	const industryItems = document.querySelectorAll('.industry-item');
	const industryContents = document.querySelectorAll('.industry-content');

	industryItems.forEach((item, index) => {
		item.addEventListener('click', () => {
			// Remove active class from all items and contents
			industryItems.forEach(i => i.classList.remove('active'));
			industryContents.forEach(c => {
				c.classList.remove('active');
				c.classList.add('hidden');
			});

			// Add active class to clicked item and show corresponding content
			item.classList.add('active');
			if (industryContents[index]) {
				industryContents[index].classList.add('active');
				industryContents[index].classList.remove('hidden');
			}
		});
	});

	// Tooltip functionality for threat map hotspots
	const hotspots = document.querySelectorAll('.threat-hotspot');

	hotspots.forEach(hotspot => {
		hotspot.addEventListener('mouseenter', function () {
			const tooltip = document.createElement('div');
			tooltip.className = 'hotspot-tooltip';
			tooltip.textContent = this.getAttribute('data-tooltip');

			this.appendChild(tooltip);
		});

		hotspot.addEventListener('mouseleave', function () {
			const tooltip = this.querySelector('.hotspot-tooltip');
			if (tooltip) {
				tooltip.remove();
			}
		});
	});

	// Live threat feed simulation
	const threatFeed = document.querySelector('.threat-grid');
	if (threatFeed) {
		// Simulate new threat detection every 30 seconds
		setInterval(() => {
			const cards = threatFeed.querySelectorAll('.threat-card');
			const randomCard = cards[Math.floor(Math.random() * cards.length)];

			// Add pulse effect
			randomCard.classList.add('pulse');

			// Remove pulse effect after animation completes
			setTimeout(() => {
				randomCard.classList.remove('pulse');
			}, 2000);
		}, 30000);
	}
});
// CVE Tracker Filter Functionality
document.addEventListener('DOMContentLoaded', function () {
	const severityFilter = document.getElementById('severity-filter');
	const vendorFilter = document.getElementById('vendor-filter');
	const statusFilter = document.getElementById('status-filter');
	const cveRows = document.querySelectorAll('#cve-table tbody tr');

	// Function to filter CVEs
	function filterCVEs() {
		const severityValue = severityFilter.value;
		const vendorValue = vendorFilter.value;
		const statusValue = statusFilter.value;

		cveRows.forEach(row => {
			const rowSeverity = row.getAttribute('data-severity');
			const rowVendor = row.getAttribute('data-vendor');
			const rowStatus = row.getAttribute('data-status');

			// Check if row matches all selected filters
			const severityMatch = severityValue === 'all' || rowSeverity === severityValue;
			const vendorMatch = vendorValue === 'all' || rowVendor === vendorValue;
			const statusMatch = statusValue === 'all' || rowStatus === statusValue;

			if (severityMatch && vendorMatch && statusMatch) {
				row.style.display = '';
			} else {
				row.style.display = 'none';
			}
		});
	}

	// Add event listeners to all filters
	severityFilter.addEventListener('change', filterCVEs);
	vendorFilter.addEventListener('change', filterCVEs);
	statusFilter.addEventListener('change', filterCVEs);
});
